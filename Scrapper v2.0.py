import requests, csv, os, datetime, time

# Replace "your_api_key_here" with your API from those platfoms

# CoinMarketCap
CMC_API_KEY = "your_cmc_api_key_here"
# LiveCoinWatch
LIVECOINWATCH_API_KEY = "your_lwc_api_key_here"
# Coin Rankings
COINRANKINGS yi_API_KEY = "your_cr_api_key_here"

# Stablecoins to exclude
STABLECOINS = {'USDT', 'USDC', 'BUSD', 'DAI', 'WETH','UST', 'TUSD', 'USDP', 'USDD', 'FRAX', 'GUSD', 'LUSD', 'FDUSD'}

def short_num(n):
    if n >= 1_000_000_000: return f"{n/1_000_000_000:.2f}B"
    elif n >= 1_000_000: return f"{n/1_000_000:.2f}M"
    elif n >= 1_000: return f"{n/1_000:.2f}K"
    else: return str(round(n))

def get_flipping_emoji(flipping_multiple):
    if flipping_multiple >= 10: return "üöÄüöÄüöÄ"
    elif flipping_multiple >= 5: return "üöÄüöÄ"
    elif flipping_multiple >= 3: return "üöÄ"
    elif flipping_multiple >= 2: return "üî•"
    elif flipping_multiple >= 1.5: return "‚≠ê"
    else: return "‚úÖ"

def create_html_report(hot_tokens, save_path):
    """Create HTML report of high-volume tokens"""
    date_prefix = datetime.datetime.now().strftime("%d-%m-%y")
    html_file = os.path.join(save_path, f"{date_prefix} volume hunting.html")
    
    current_time = datetime.datetime.now().strftime("%d-%m-%Y %H:%M:%S")
    
    # Calculate statistics
    max_flip = max(t['flipping_multiple'] for t in hot_tokens) if hot_tokens else 0
    high_volume = len([t for t in hot_tokens if t['flipping_multiple'] >= 2])
    large_cap_count = len([t for t in hot_tokens if t['large_cap']])
    
    # Create Our HTML content
    html_content = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>Volume Hunter v2.0</title>
        <style>
            body {{ font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }}
            .header {{ text-align: center; background-color: #2c3e50; color: white; padding: 20px; border-radius: 10px; }}
            .summary {{ background-color: #34495e; color: white; padding: 15px; border-radius: 8px; margin: 10px 0; }}
            .table {{ width: 100%; border-collapse: collapse; background-color: white; }}
            .table th {{ background-color: #3498db; color: white; padding: 12px; text-align: left; }}
            .table td {{ padding: 10px; border-bottom: 1px solid #ddd; }}
            .table tr:nth-child(even) {{ background-color: #f2f2f2; }}
            .table tr:hover {{ background-color: #e8f4f8; }}
            .footer {{ text-align: center; margin-top: 20px; color: #7f8c8d; }}
            .large-cap {{ background-color: #e8f6f3 !important; }}
            .high-volume {{ color: #e74c3c; font-weight: bold; }}
        </style>
    </head>
    <body>
        <div class="header">
            <h1>SPOT VOLUME HUNTER v2.0</h1>
            <p>High Volume Spot Tokens Analysis</p>
            <p><small>Generated on: {current_time}</small></p>
        </div>
        
        <div class="summary">
            <h3>Summary</h3>
            <p>Total High-Volume Tokens: {len(hot_tokens)}</p>
            <p>Peak Flipping Multiple: {max_flip:.1f}x</p>
            <p>High-Volume Tokens (2x+): {high_volume}</p>
            <p>Large-Cap Tokens (>$1B): {large_cap_count}</p>
        </div>
    """
    
    if hot_tokens:
        html_content += """
        <table class="table">
            <tr>
                <th>Rank</th>
                <th>Ticker</th>
                <th>Market Cap</th>
                <th>Volume 24h</th>
                <th>Flip Multiple</th>
                <th>Verifications</th>
                <th>Large Cap</th>
            </tr>
        """
        
        for i, token in enumerate(hot_tokens):
            row_class = "large-cap" if token['large_cap'] else ""
            volume_class = "high-volume" if token['flipping_multiple'] >= 2 else ""
            html_content += f"""
            <tr class="{row_class}">
                <td>#{i+1}</td>
                <td><b>{token['symbol']}</b></td>
                <td>${short_num(token['marketcap'])}</td>
                <td>${short_num(token['volume'])}</td>
                <td class="{volume_class}">{token['flipping_multiple']:.1f}x</td>
                <td>{token['source_count']}</td>
                <td>{'Yes' if token['large_cap'] else 'No'}</td>
            </tr>
            """
        
        html_content += "</table>"
    else:
        html_content += "<div style='text-align: center; padding: 40px;'><h3>No high-volume tokens found</h3></div>"
    
    html_content += f"""
        <div class="footer">
            <p>Auto Generated by Spot Volume Hunter v2.0 | By (@traderabba)</p>
        </div>
    </body>
    </html>
    """
    
    with open(html_file, "w", encoding="utf-8") as f:
        f.write(html_content)
    
    return html_file

def fetch_coingecko():
    tokens = []
    print("üîç CoinGecko...")
    for page in range(1, 5):
        url = "https://api.coingecko.com/api/v3/coins/markets"
        params = {"vs_currency": "usd", "order": "market_cap_desc", "per_page": 250, "page": page}
        try:
            response = requests.get(url, params=params, timeout=20)
            if response.status_code == 200:
                data = response.json()
                for t in data:
                    symbol = t.get("symbol", "").upper()
                    if symbol in STABLECOINS: continue
                    volume = t.get("total_volume", 0)
                    marketcap = t.get("market_cap", 0)
                    
                    if marketcap and volume > 0.75 * marketcap:
                        volume_ratio = volume / marketcap
                        tokens.append({
                            "symbol": symbol, 
                            "marketcap": marketcap, 
                            "volume": volume, 
                            "volume_ratio": volume_ratio,
                            "source": "CG"
                        })
                        emoji = get_flipping_emoji(volume_ratio)
                        print(f"   {emoji} {symbol} from CG: {volume_ratio:.1f}x (MC: ${short_num(marketcap)})")
            time.sleep(1)
        except: continue
    print(f"‚úÖ {len(tokens)} tokens from CoinGecko")
    return tokens

def fetch_coinmarketcap():
    tokens = []
    print("üîç CoinMarketCap...")
    headers = {"X-CMC_PRO_API_KEY": CMC_API_KEY}
    
    for start in range(1, 1001, 100):
        url = "https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest"
        params = {"start": start, "limit": 100, "convert": "USD"}
        try:
            response = requests.get(url, headers=headers, params=params, timeout=20)
            if response.status_code == 200:
                data = response.json().get("data", [])
                for t in data:
                    symbol = t.get("symbol", "").upper()
                    if symbol in STABLECOINS: continue
                    quote = t.get("quote", {}).get("USD", {})
                    volume = quote.get("volume_24h", 0)
                    marketcap = quote.get("market_cap", 0)
                    
                    if marketcap and volume > 0.75 * marketcap:
                        volume_ratio = volume / marketcap
                        tokens.append({
                            "symbol": symbol, 
                            "marketcap": marketcap, 
                            "volume": volume, 
                            "volume_ratio": volume_ratio,
                            "source": "CMC"
                        })
                        emoji = get_flipping_emoji(volume_ratio)
                        print(f"   {emoji} {symbol} from CMC: {volume_ratio:.1f}x (MC: ${short_num(marketcap)})")
            time.sleep(1)
        except: continue
    
    print(f"‚úÖ {len(tokens)} tokens from CoinMarketCap")
    return tokens

def fetch_livecoinwatch():
    tokens = []
    if LIVECOINWATCH_API_KEY == "your_livecoinwatch_api_key_here":
        return tokens
        
    print("üîç LiveCoinWatch...")
    url = "https://api.livecoinwatch.com/coins/list"
    headers = {"content-type": "application/json", "x-api-key": LIVECOINWATCH_API_KEY}
    payload = {"currency": "USD", "sort": "rank", "order": "ascending", "offset": 0, "limit": 1000, "meta": True}
    
    try:
        response = requests.post(url, json=payload, headers=headers, timeout=20)
        if response.status_code == 200:
            data = response.json()
            for t in data:
                symbol = t.get("code", "").upper()
                if symbol in STABLECOINS: continue
                volume = t.get("volume", 0)
                marketcap = t.get("cap", 0)
                
                if marketcap and volume > 0.75 * marketcap:
                    volume_ratio = volume / marketcap
                    tokens.append({
                        "symbol": symbol, 
                        "marketcap": marketcap, 
                        "volume": volume, 
                        "volume_ratio": volume_ratio,
                        "source": "LCW"
                    })
                    emoji = get_flipping_emoji(volume_ratio)
                    print(f"   {emoji} {symbol} from LCW: {volume_ratio:.1f}x (MC: ${short_num(marketcap)})")
    except: pass
    
    print(f"‚úÖ {len(tokens)} tokens from LiveCoinWatch")
    return tokens

def fetch_coinrankings():
    tokens = []
    print("üîç CoinRankings...")
    
    headers = {"x-access-token": COINRANKINGS_API_KEY}
    url = "https://api.coinranking.com/v2/coins"
    for offset in range(0, 1000, 100):
        params = {"limit": 100, "offset": offset, "orderBy": "marketCap", "orderDirection": "desc"}
        
        try:
            response = requests.get(url, headers=headers, params=params, timeout=20)
            if response.status_code == 200:
                data = response.json()
                coins = data.get("data", {}).get("coins", [])
                for coin in coins:
                    symbol = coin.get("symbol", "").upper()
                    if symbol in STABLECOINS: continue
                    volume = float(coin.get("24hVolume", "0"))
                    marketcap = float(coin.get("marketCap", "0"))
                    
                    if marketcap and volume > 0.75 * marketcap:
                        volume_ratio = volume / marketcap
                        tokens.append({
                            "symbol": symbol, 
                            "marketcap": marketcap, 
                            "volume": volume, 
                            "volume_ratio": volume_ratio,
                            "source": "CR"
                        })
                        emoji = get_flipping_emoji(volume_ratio)
                        print(f"   {emoji} {symbol} from CR: {volume_ratio:.1f}x (MC: ${short_num(marketcap)})")
            time.sleep(1)
        except: pass
    
    print(f"‚úÖ {len(tokens)} tokens from CoinRankings")
    return tokens

def is_large_cap_token(tokens):
    """Check if any token in the list has market cap > $1B"""
    for token in tokens:
        if token['marketcap'] > 1_000_000_000:  # $1B threshold
            return True
    return False

def calculate_simple_metrics(tokens):
    """Simple metrics calculation for single-source tokens"""
    volume = tokens[0]['volume']
    marketcap = tokens[0]['marketcap']
    volume_ratio = volume / marketcap if marketcap > 0 else 0
    return volume, marketcap, volume_ratio

def fetch_and_save():
    print("   üëÅÔ∏è Be patient bro...")
    print("   üì° Scanning for High-volume in the Last 24 Hours..")
    print("   üéØ Other Tokens Volume > 75% of MC")
    print("   üì¢  Don't Second-guess Large-Cap Tokens ($1B+)")
    print("   ‚úÖ Large-cap Volume >= 50% of their MC")
    print("=" * 50)

    # Fetch data from all APIs
    cg_data = fetch_coingecko()
    cmc_data = fetch_coinmarketcap() 
    lcw_data = fetch_livecoinwatch()
    cr_data = fetch_coinrankings()
    
    print(f"üìä Raw results: CG={len(cg_data)}, CMC={len(cmc_data)}, LCW={len(lcw_data)}, CR={len(cr_data)}")
    
    # Combine all data
    all_data = {}
    for token in cg_data + cmc_data + lcw_data + cr_data:
        symbol = token['symbol']
        if symbol not in all_data:
            all_data[symbol] = []
        all_data[symbol].append(token)
    
    # Enhanced filtering - ALLOW LARGE-CAP TOKENS WITH SINGLE VERIFICATION
    verified_tokens = []
    
    for symbol, tokens in all_data.items():
        # Allow large-cap tokens ($1B+) with single API verification
        if len(tokens) == 1 and is_large_cap_token(tokens):
            volume, marketcap, volume_ratio = calculate_simple_metrics(tokens)
            
            if volume_ratio >= 0.50:
                verified_tokens.append({
                    "symbol": symbol,
                    "marketcap": marketcap, 
                    "volume": volume,
                    "volume_ratio": volume_ratio,
                    "flipping_multiple": volume_ratio,
                    "source_count": 1,
                    "large_cap": True
                })
        
        # Normal case: Multi-API verification for smaller tokens
        elif len(tokens) >= 2:
            # Use existing verification logic for smaller tokens
            volumes = [t['volume'] for t in tokens]
            marketcaps = [t['marketcap'] for t in tokens]
            
            # Simple average for multi-source tokens
            avg_volume = sum(volumes) / len(volumes)
            avg_marketcap = sum(marketcaps) / len(marketcaps)
            volume_ratio = avg_volume / avg_marketcap if avg_marketcap > 0 else 0
            
            if volume_ratio > 0.75:
                verified_tokens.append({
                    "symbol": symbol,
                    "marketcap": avg_marketcap, 
                    "volume": avg_volume,
                    "volume_ratio": volume_ratio,
                    "flipping_multiple": volume_ratio,
                    "source_count": len(tokens),
                    "large_cap": is_large_cap_token(tokens)
                })
    
    # Sort by volume ratio
    hot_tokens = sorted(verified_tokens, key=lambda x: x["flipping_multiple"], reverse=True)

    # Save to multiple formats
    save_path = "/sdcard/Download"
    date_prefix = datetime.datetime.now().strftime("%d-%m-%y")
    
    # CSV file
    csv_file = os.path.join(save_path, f"{date_prefix} volume hunting.csv")
    with open(csv_file, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        
        writer.writerow([])
        writer.writerow(["","", "", "VOL. HUNTER v2.0", "",""])
        writer.writerow([])
        
        writer.writerow(["Ticker", "Marketcap", "Volume", "Vol. Flip MC", "Verifications", "Large Cap"])
        
        for t in hot_tokens:
            writer.writerow([
                t["symbol"], 
                short_num(t["marketcap"]), 
                short_num(t["volume"]),
                f"{t['flipping_multiple']:.1f}x",
                t["source_count"],
                "Yes" if t["large_cap"] else "No"
            ])
        
        writer.writerow([])
        writer.writerow(["","", "", "By (@traderabba)","",""])

    # HTML report
    html_file = create_html_report(hot_tokens, save_path)

    # Display all results
    now = datetime.datetime.now().strftime("%H:%M:%S")
    print(f"‚úÖ {len(hot_tokens)} high-volume tokens at {now}")
    print(f"üíæ Saved CSV: {csv_file}")
    print(f"üåê Saved HTML: {html_file}\n")
    
    if hot_tokens:
        print("üèÜ HIGH-VOLUME TOKENS:")
        print("=" * 80)
        for i, token in enumerate(hot_tokens):
            emoji = get_flipping_emoji(token['flipping_multiple'])
            large_cap_indicator = " üíé" if token['large_cap'] else ""
            print(f"#{i+1:2d}. {token['symbol']:8} {emoji} {token['flipping_multiple']:.1f}x "
                  f"| MC: ${short_num(token['marketcap']):>8} | Verifications: {token['source_count']}{large_cap_indicator}")
        
        print("=" * 80)
        max_flip = max(t['flipping_multiple'] for t in hot_tokens)
        high_volume = len([t for t in hot_tokens if t['flipping_multiple'] >= 2])
        large_cap_count = len([t for t in hot_tokens if t['large_cap']])
        
        print(f"üìà Peak: {max_flip:.1f}x | High-volume: {high_volume} tokens")
        print(f"üíé Large-cap (>$1B): {large_cap_count} tokens")
        
    else:
        print("‚ùå No high-volume tokens found")

# Main Loop
print("  üöÄ SPOT TRADING 24HR VOLUME HUNTER v2.0")
print("  üòç Brought to You by Trader Abba")
print("  üëâ Follow me @TraderAbba ")
print("  ‚è∞ Auto-updates every hour")
print("  üéØ General Tokens Volume > 75% of MC")
print("  üíé Large-cap volume >= 50% of MC")
print("=" * 50)

while True:
    fetch_and_save()
    print("‚è≥ Next scan in 1 hour...\n")
    time.sleep(3600)
